using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace task3
{
    class Program
    {
        // Задание 3. Создать метод, принимающий текст. 
        // Результатом работы метода должен быть новый текст, в котором
        // удалены все кратные рядом стоящие символы, оставив по одному 
        // Пример: ПППОООГГГООООДДДААА >>> ПОГОДА
        // Пример: Ххххоооорррооошшшиий деееннннь >>> хороший день

        static void Main(string[] args)
        {
            string text = "ПППОООГГГООООДДДААА";
            string text2 = "Ххххоооорррооошшшиий деееннннь";
            ReturnStringWithoutDuplicate(text); //пример №1
            ReturnStringWithoutDuplicate(text2.ToLower()); //пример №2 с приведением символов к нижнему регистру
            Console.ReadKey();
        }

        /// <summary>
        /// удаляет рядом стоящие повторяющиеся символы
        /// </summary>
        /// <param name="s"></param>
        static void ReturnStringWithoutDuplicate(string s)
        {
            int count = 0; //счётчик повторяющихся символов, для перехода на новый символ после окончания повторов
            Stack<char> letter = new Stack<char>(); //новый для меня способ сохранения промежуточного результата

            for (int i = 0; i < s.Length;)  //цикл прохода по символам в строке
            {
                if (i == s.Length - 1)  //исключение на случай если получили для проверки на повторы последний символ, после которого уже не возможны повторения
                {
                    letter.Push(s[i]);  //отправляем последний символ в стек
                    break;
                }
                for (int l = i + 1; l < s.Length; l++)  //цикл сравнения на повторы текущего для проверки символа с символами стоящими дальше в последовательности
                {
                    if (s[i] == s[l])   //условие для действий в случае повтора символа
                    {
                        ++count; //прирост счетчика повтора, для вычисления следующего символа для проверки после окончания повторов текущего
                        if (i + count == s.Length)  //условие исключения если последний символ повторяется и не выполнится условие прерывания проверки текущего символа
                        {
                            letter.Push(s[i]);  //отправляет в стек последний символ в случае его дальнейшего повтора
                            i += count+1; //прирост переменной для выхода из основного цикла проверки символов (текущая позиция + кол-во повторов + шаг на след позицию)
                            break;  //прерываение вложенного цикла проверки следом стоящих символов
                        }
                        continue; //переход на новую итерацию проверки следом стоящих символов
                    }
                    else if (s[i] != s[l]) //условие прерывания проверки повторов текущего проверяемого символа, в случае если следом стоящий ему не эквивалентен
                    {
                        letter.Push(s[i]);  //отправка в стек проверяемого символа
                        i += count+1; //прирост переменной с учётом повторяющихся символов для перехода на след. проверяемый символ (текущая позиция + кол-во повторов + шаг на след позицию)
                        count = 0; //обнеление кол-во повторов
                        break;
                    }
                }
            }

            char[] output = new char[letter.Count]; //массив символов без повторов по размеру стека содержащего вложенные символы
            output = letter.ToArray(); //значения стека перекладываем в массив
            Array.Reverse(output);  //разворачиваем массив в обратную сторону
            foreach (char e in output)  //вывод посимвольно
            {
                Console.Write(e);
            }
            Console.WriteLine(); //для перехода на след строку если повторный вызов метода
        }
    }
}
